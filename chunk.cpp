#include "chunk.h"GLfloat Chunk::maxHeight = 10.0f;GLfloat Chunk::maxDeltaHeight = 0.5f;int Chunk::maxTreesNum = 5;int Chunk::maxGrassNum = 300;void Chunk::setSide(Side side, GLfloat data[MAP_SIZE][MAP_SIZE]){	switch(side)	{	case Chunk::Left:		for(int i = 0; i < MAP_SIZE; ++i)		{			heightMap[0][i] = data[MAP_SIZE - 1][i];		}		break;	case Chunk::Bottom:		for(int i = 0; i < MAP_SIZE; ++i)		{			heightMap[i][0] = data[i][MAP_SIZE - 1];		}		break;	case Chunk::Right:		for(int i = 0; i < MAP_SIZE; ++i)		{			heightMap[MAP_SIZE - 1][i] = data[0][i];		}		break;	case Chunk::Top:		for(int i = 0; i < MAP_SIZE; ++i)		{			heightMap[i][MAP_SIZE - 1] = data[i][0];		}		break;	}}void Chunk::generate(){	if(heightMap[0][0] < -9000.0f)	{		heightMap[0][0] = rand() % 1001 / 1000.0f * maxHeight;	}	if(heightMap[0][MAP_SIZE - 1] < -9000.0f)	{		heightMap[0][MAP_SIZE - 1] = rand() % 1001 / 1000.0f * maxHeight;	}	if(heightMap[MAP_SIZE - 1][0] < -9000.0f)	{		heightMap[MAP_SIZE - 1][0] = rand() % 1001 / 1000.0f * maxHeight;	}	if(heightMap[MAP_SIZE - 1][MAP_SIZE - 1] < -9000.0f)	{		heightMap[MAP_SIZE - 1][MAP_SIZE - 1] = rand() % 1001 / 1000.0f * maxHeight;	}		for(unsigned int i = MAP_SIZE - 1; i > 1; i >>= 1)	{		for(unsigned int j = 0; j < MAP_SIZE - 1; j += i)		{			for(unsigned int k = 0; k < MAP_SIZE - 1; k += i)			{				generateQuad(j, k, i);			}		}	}		int x, z;		bool canGenerate;	for(int i = 0; i < maxTreesNum; ++i)	{		x = 1 + rand() % (MAP_SIZE - 2);		z = 1 + rand() % (MAP_SIZE - 2);		canGenerate = true;		for(int j = 0; j < treesCoord.size(); ++j)		{			if((treesCoord[j].x() == x) && (treesCoord[j].y() == z))			{				canGenerate = false;				break;			}		}				if(canGenerate)		{			cellType[x][z] = TREE;			Tree tmp;			TreeLibLeafProperties leafProperties;			leafProperties.texture = "leaf.png";			leafProperties.coff = 1.0;			trees.push_back(tmp);			trees[trees.size() - 1].addLeafType(leafProperties);			trees[trees.size() - 1].generate(0.0f, 0.0f, 0.0f);						QPoint tmpPoint(x - MAP_SIZE / 2, z - MAP_SIZE / 2);			treesCoord.push_back(tmpPoint);		}	}		for(int i = 0; i < maxGrassNum; ++i)	{		x = 1 + rand() % (MAP_SIZE - 2);		z = 1 + rand() % (MAP_SIZE - 2);		if(cellType[x][z] == EMPTY)		{			cellType[x][z] = BUSH;		}	}}void Chunk::generateQuad(int x, int y, int size){	if(heightMap[x + size / 2][y] < -9000.0f)	{		heightMap[x + size / 2][y] = (heightMap[x][y] + heightMap[x + size][y]) / 2.0f + 			(rand() % 2001 - 1000) / 1000.0f * maxDeltaHeight * size;	}	if(heightMap[x][y + size / 2] < -9000.0f)	{		heightMap[x][y + size / 2] = (heightMap[x][y] + heightMap[x][y + size]) / 2.0f + 			(rand() % 2001 - 1000) / 1000.0f * maxDeltaHeight * size;	}	if(heightMap[x + size][y + size / 2] < -9000.0f)	{		heightMap[x + size][y + size / 2] = (heightMap[x + size][y] + heightMap[x + size][y + size]) / 2.0f + 			(rand() % 2001 - 1000) / 1000.0f * maxDeltaHeight * size;	}	if(heightMap[x + size / 2][y + size] < -9000.0f)	{		heightMap[x + size / 2][y + size] = (heightMap[x][y + size] + heightMap[x + size][y + size]) / 2.0f + 			(rand() % 2001 - 1000)/ 1000.0f * maxDeltaHeight * size;	}		heightMap[x + size / 2][y + size / 2] = (heightMap[x + size / 2][y] + heightMap[x][y + size / 2] + heightMap[x + size][y + size / 2] +		heightMap[x + size / 2][y + size]) / 4.0f + (rand() % 2001 - 1000)/ 1000.0f * maxDeltaHeight * size;}void Chunk::clear(){	for(int i = 0; i < MAP_SIZE; ++i)	{		for(int j = 0; j < MAP_SIZE; ++j)		{			heightMap[i][j] = -9999.0f;			cellType[i][j] = EMPTY;		}	}	trees.clear();	treesCoord.clear();}void Chunk::operator=(const Chunk& chunk){	for(int i = 0; i < MAP_SIZE; ++i)	{		for(int j = 0; j < MAP_SIZE; ++j)		{			heightMap[i][j] = chunk.heightMap[i][j];			cellType[i][j] = chunk.cellType[i][j];		}	}	trees = chunk.trees;	treesCoord = chunk.treesCoord;}